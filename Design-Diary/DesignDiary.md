# Design Diary - SSH Client QT - 04/08/2020 

For this assignment, we were tasked with creating a QT application. The base requirements were to either create a music player, or connect to a previous project. My idea went in a different direction, as I wanted design something to interact with devices over SSH. I also liked the idea we looked at in class of making a login system connected to a Flask app, so I wanted to incorporate that into my project as well. Making the login and sign up system was pretty fun, and I used cool modules like flask_sqlalchemy to manage a SQLite database and werkzeug.security to hash passwords when they got stored in the database. I then used the format of returning certain messages and status codes to log users in properly on the QT side. I also had a lot of fun implementing the paramiko library, which I had never used before, and had decent documentation. A couple things that I had trouble with were creating and destroying windows, and saving files on the client side of the ssh connection. For managing the windows, Adam gave me a really great idea to create an "invisible window" that acted as a manager and used transition methods to close windows and open them. This was fairly simple to implement, and once I got it working, sped up my program dramatically, as I no longer had to call os.system('python filename') to open new windows, and didn't have to cache and read text files to pass data like login information on to the next window. As for saving files on the client side, I tried a couple of things that people recommended on Stack Overflow, but that didn't work. The first suggestion was to use execute the command `echo -e '{file_contents}' > {path_and_file_name}`, which kept giving me a permision denied, despite prefacing the command with `sudo -S -p ''` and passing in the password to stdin before flushing stdin (how you run other sudo commands through paramiko). When this didn't work, I tried another suggestion, which was to use paramiko's sftp module to remove a file, and then put a new file with the new contents in it's place. This also did not work as the sftp module has no way to add sudo privilages to the remove() command, which means you either need to change the permissions of all the files, or that you needed to keep looking for a different solution. Eventually, I tried running the `echo -e text > filename` command in a Putty session and found out that I couldn't get the permissions to use that command even when specifying sudo before the command. This told me that I neede a new way to overwrite a file with bash commands, so I looked into that and found the `echo {text} | sudo tee {filename}` command. This command actually solved the problem for the most part (except for random connection drops while saving the file), and was very satisfying to get past.

All in all, I feel like this project taught me a lot about server/code interactions, and I found it very cool to be able to create something that I could use to interact with other machines, rather than just my host.